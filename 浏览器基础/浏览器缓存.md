# 浏览器缓存


<b>` 为什么要使用缓存？  `</b><br/>

` 设置缓存后，我们可以把第一次访问到的资源存在本地，第二次去访问时就直接可以访问本地的资源，无需二次请求服务器。`


## 缓存策略

`浏览器的缓存策略分为 强缓存 和 协商缓存，均通过 HTTP header 来实现 `

### 强缓存

 - 【实现方式】 设置 HTTP header 的 `Expires` 和 `Cache-Control`
 - 【是否发起服务器请求】不会向服务器发送请求，直接从缓存中读取资源
 - 【优先级】   `Cache-Control` 高于 `Expires`

    #### Expires

        HTTP/1 时期产生，缓存过期时间，用于指定资源的到期时间，由服务器设置
        Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，
        缺点：该时间受限于本地时间，若修改了本地时间，可能会导致缓存失效。

    #### Cache-Control
    
        HTTP/1.1 时期产生，比如当设置
        * Cache-Control:max-age=300，单位是 s，代表 300s 分钟内再次请求就会走强缓存，如果和 Last-Modified 一起使用，则 Cache-Control 的优先级更高
        * no-cache:==  不使用强缓存，使用协商缓存
        * no-store:==  不使用缓存，每次都从服务器重新拉取资源，所有资源都不会被缓存
        * public  所有内容都会被缓存，客户端和代理服务器都可以缓存。
        * private 内容只能缓存在私有缓存中，即只有客户端可以缓存该资源，代理服务器不可以。



### 协商缓存

协商缓存就是强缓存失效之后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

- 【实现方式】`Last-Modified` 和 `ETag`
- 【对比】 `ETag`更精确 ，`Last-Modified` 性能更好


#### Last-Modified
    HTTP1.0 时期产生，浏览器第一次请求资源时，服务器会在 response 的 header 里加上 Last-Modified 的时间点，表示服务器最后修改该资源的时间

    当浏览器第二次请求该资源时，检测到缓存文件里面有 Last-Modified，那么就会在请求头中加上 `If-Modified-Since`，值为上一次 `Last-Modified` 的值，服务器收到了 `If-Modified-Since` 这个值，就会拿这个值和请求文件最后修改时间作对比，若一致，返回 304；若小于最后修改时间，说明发生了变化，则返回新的资源和新的 Last-Modified，状态码 200。

    存在的问题：
    1. 由于 Last-Modified 的最小粒度是秒级的，如果有的文件更新是小于秒级的那么是无法检测出来的
    2. 某些服务器不能精确的获得文件的修改时间


#### ETag
    Etag 是作为 Last-Modified 的补充出现的，它相对于 Last-Modified 要更加严谨。
    服务器会对请求的文件进行散列值计算，得出一个唯一的 token。将它作为 ETag 的值。

    ETag 在 HTTP1.1 时期产生，浏览器第一次请求资源时，response.headers 里会加上 ETag，值为一个新的 token，第二次请求时，该值会被放在请求头的 If-None-Match 上，服务器对请求的资源散列值计算，得出的值和 If-None-Match 一致，返回 304，不一致，返回新资源和新的 ETag，状态码 200.

